// Generated SDK - DO NOT EDIT MANUALLY
// This file is automatically generated from server API specifications

export interface SDKConfig {
  token: string;
  baseUrl: string;
  timeout: number;
  retries: number;
}

export interface RequestOptions {
  params?: Record<string, any>;
  headers?: Record<string, string>;
  timeout?: number;
}

export interface APIResponse<T = any> {
  data: T;
  status: number;
  headers: Record<string, string>;
}

export interface APIError {
  message: string;
  code: string;
  status: number;
}

class BaseClient {
  constructor(protected config: SDKConfig, protected basePath: string) {}

  protected async request(options: {
    method: string;
    path: string;
    data?: any;
    params?: Record<string, any>;
    headers?: Record<string, string>;
  }): Promise<APIResponse> {
    const url = new URL(`${this.config.baseUrl}${this.basePath}${options.path}`);
    
    // Add query parameters
    if (options.params) {
      Object.entries(options.params).forEach(([key, value]) => {
        url.searchParams.append(key, String(value));
      });
    }

    const requestHeaders: Record<string, string> = {
      'Content-Type': 'application/json',
      'Authorization': `Bearer ${this.config.token}`,
      'User-Agent': 'Nodash-SDK/1.0.0',
      ...options.headers
    };

    const requestInit: RequestInit = {
      method: options.method,
      headers: requestHeaders,
    };

    if (options.data && ['POST', 'PUT', 'PATCH'].includes(options.method)) {
      requestInit.body = JSON.stringify(options.data);
    }

    try {
      const response = await fetch(url.toString(), requestInit);
      
      const responseHeaders: Record<string, string> = {};
      response.headers.forEach((value, key) => {
        responseHeaders[key] = value;
      });

      let data: any;
      const contentType = response.headers.get('content-type');
      if (contentType && contentType.includes('application/json')) {
        data = await response.json();
      } else {
        data = await response.text();
      }

      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${data.message || data}`);
      }

      return {
        data,
        status: response.status,
        headers: responseHeaders
      };
    } catch (error) {
      if (error instanceof Error) {
        throw new Error(`Request failed: ${error.message}`);
      }
      throw new Error('Request failed with unknown error');
    }
  }
}

export class AnalyticsServerClient extends BaseClient {
  constructor(config: SDKConfig) {
    super(config, '/analytics-server');
  }

  /**
   * Track an analytics event
   */
  async trackEvent(data: any, options?: RequestOptions): Promise<APIResponse> {
    return this.request({
      method: 'POST',
      path: '/events',
      data,
      ...options
    });
  }

  /**
   * Track multiple analytics events
   */
  async trackEventsBatch(data: any, options?: RequestOptions): Promise<APIResponse> {
    return this.request({
      method: 'POST',
      path: '/events/batch',
      data,
      ...options
    });
  }

  /**
   * Get server health status
   */
  async getHealthStatus(options?: RequestOptions): Promise<APIResponse> {
    return this.request({
      method: 'GET',
      path: '/health',
      
      ...options
    });
  }
}


export class BiServerClient extends BaseClient {
  constructor(config: SDKConfig) {
    super(config, '/bi-server');
  }

  /**
   * Get available dashboards
   */
  async getDashboards(options?: RequestOptions): Promise<APIResponse> {
    return this.request({
      method: 'GET',
      path: '/dashboards',
      
      ...options
    });
  }

  /**
   * Get a specific report
   */
  async getReport(options?: RequestOptions): Promise<APIResponse> {
    return this.request({
      method: 'GET',
      path: '/reports/{reportId}',
      
      ...options
    });
  }
}


export class MonitoringServerClient extends BaseClient {
  constructor(config: SDKConfig) {
    super(config, '/monitoring-server');
  }

  /**
   * Report an application error
   */
  async reportError(data: any, options?: RequestOptions): Promise<APIResponse> {
    return this.request({
      method: 'POST',
      path: '/errors',
      data,
      ...options
    });
  }

  /**
   * Submit performance metrics
   */
  async submitMetrics(data: any, options?: RequestOptions): Promise<APIResponse> {
    return this.request({
      method: 'POST',
      path: '/metrics',
      data,
      ...options
    });
  }
}

export class NodashSDK {
  private config: SDKConfig;
  private clients: { [key: string]: any } = {};

  constructor(token: string, config: Partial<SDKConfig> = {}) {
    this.config = {
      token,
      baseUrl: 'https://api.nodash.ai',
      timeout: 30000,
      retries: 3,
      ...config
    };

    // Initialize server clients
    this.clients.analyticsServer = new AnalyticsServerClient(this.config);
    this.clients.biServer = new BiServerClient(this.config);
    this.clients.monitoringServer = new MonitoringServerClient(this.config);
  }

  // Server client getters
  get analyticsServer() { return this.clients.analyticsServer; }
  get biServer() { return this.clients.biServer; }
  get monitoringServer() { return this.clients.monitoringServer; }

  // Convenience methods for MCP server compatibility
  async track(event: string, properties: Record<string, any> = {}, options: Record<string, any> = {}): Promise<APIResponse> {
    const eventData = {
      event,
      properties,
      userId: options.userId,
      sessionId: options.sessionId,
      source: options.source || 'sdk',
      timestamp: new Date().toISOString()
    };
    
    return this.analyticsServer.trackEvent(eventData);
  }

  async sendMetric(name: string, value: number, options: { unit?: string; tags?: Record<string, string> } = {}): Promise<APIResponse> {
    const metricData = {
      name,
      value,
      unit: options.unit,
      tags: options.tags,
      timestamp: new Date().toISOString()
    };
    
    return this.monitoringServer.submitMetrics(metricData);
  }

  // Monitoring convenience getter
  get monitoring() {
    return {
      getHealth: async (): Promise<{ status: string; checks?: Record<string, any> }> => {
        const response = await this.analyticsServer.getHealthStatus();
        return response.data;
      }
    };
  }
}

// Default export
export default NodashSDK;
